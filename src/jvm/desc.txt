
//jvm
    内存与垃圾回收
    字节码与类的加载
    性能监控与调优
    大厂面试

    1.类加载系统    读取class文件
        1.三种类加载器   引导类加载器(bootstrapClassLoader)\扩展类加载器\系统类加载器
             bootStrap  classloader是c/c++ 写的  因此不能java代码不能获取到   用来加载java核心库
             扩展类加载器  和 系统类加载器(应用程序类加载器)  都是继承于classloader
             扩展类加载器 加载 ext文件夹下的类名
             自定义类获取都都是系统类加载器
                 自定义类加载器的应用场景 防止其他人根据字节码文件进行反编译  可以添加解密功能
                 自定义类的加载器  可以继承classloader 重写 findClass 方法
         2.双亲委派机制
             看上一级是否加载  具体到例子中就是   首先是系统类加载器  询问 扩展类加载器   扩展类加载器询问引导类加在器
             引导类加载器(不加载)  ---> 扩展类加载器(不加载)--->系统类加载器
             优势： 防止类的重复加载,保护核心代码不被篡改
                    比如:自己自定义 java.lang.String类  如果没有双亲委派机制
                    那么会加载自定义的String类 这就破坏了核心类的完整性
    2.运行时数据区   堆  栈  方法区(实现)  本地方法区  pc寄存器
        (1)pc寄存器  保存的是下一指令的地址  线程私有   每个线程都有一个pc寄存器  记录各自下一个指令的地址
        (2)栈  线程私有  保存一个个栈帧  栈帧对应的是一个个方法  不存在gc 有可能oom(out of memory)
           1.出现 stackoverflow  或 outofmemory  异常怎么解决
            调整 栈的大小  使用-Xss
           2.栈帧的内部结构
                局部变量表(local variable)
                  数字数组  存储单位 slot
                操作数栈(operand stack)
                动态链接(dynamic linking)  运行时常量的引用
                    指向运行时常量池中方法的引用
                方法返回地址   方法正常退出或异常退出的定义
                一些附加信息
        (3)堆
          线程共享 调整堆的大小 -Xms

          工具命令行： jps、jconsole、jmap -heap 进程号、jvisualVm

          结构：
            新生代(1/3堆空间占比)：
                伊甸园(eden)
                幸存者0区(survivor 0\form)
                幸存者1区(survivor 1\to)
                eden:form:to = 8:1:1  空间比例
            老年代(tenure；2/3堆空间占比)：
            元空间(永久 1.8以前)：
            eden的gc为ygc(轻gc), tenure 为fullgc(重gc)

           引用
               强引用（Strong Reference）
               类似 "Object obj = new Object()" 这类的引用，就是强引用，只要强引用存在，
               垃圾收集器永远不会回收被引用的对象。但是，如果我们错误地保持了强引用，
               比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。

           软引用（Soft Reference）
                软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，
                只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。
                JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。
                软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，
                当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

           弱引用（Weak Reference）
                弱引用的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。

           虚引用（Phantom Reference）
               虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，
               完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，
               做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。
           垃圾收集算法
             1.标记-清除算法
                标记的过程是：遍历所有的 GC Roots，然后将所有 GC Roots 可达的对象标记为存活的对象。
                清除的过程将遍历堆中所有的对象，将没有标记的对象全部清除掉。与此同时，清除那些被标记过的对象的标记，以便下次的垃圾回收。
                这种方法有两个不足：
                    效率问题：标记和清除两个过程的效率都不高。
                    空间问题：标记清除之后会产生大量不连续的内存碎片，碎片太多可能导致以后需要分配较大对象时，
                    无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
             2.复制算法（新生代）
                为了解决效率问题，“复制”收集算法出现了。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
                当这一块内存用完，需要进行垃圾收集时，就将存活者的对象复制到另一块上面，然后将第一块内存全部清除。
                这种算法有优有劣：
                    优点：不会有内存碎片的问题。
                    缺点：内存缩小为原来的一半，浪费空间。
                为了解决空间利用率问题，可以将内存分为三块： Eden、From Survivor、To Survivor，比例是 8:1:1，
                每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，
                最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。
                但是我们无法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够，需要依赖其他内存（指老年代）进行分配担保。
             3.标记-整理算法（老年代）
                标记：它的第一个阶段与标记/清除算法是一模一样的，均是遍历 GC Roots，然后将存活的对象标记。
                整理：移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收。
                因此，第二阶段才称为整理阶段。
             4.分代收集算法
                 新生代：复制算法
                 老年代：标记-清除算法、标记-整理算法

        (4)方法区(逻辑上是堆的一部分  其实不是)：
              class   classLoader 常量池
              方法区的实现  1.8以前 永久代 1.8 元空间 元空间使用本机物理内存
              查看字节码
              javap -v .class
              StringTable  是在运行时常量池中 存储的是指向String对象的索引，真实对象还是存储在堆中。
              方法区中存放生命周期较长的类信息、常量、静态变量，每次垃圾收集只有少量的垃圾被清除。
                  方法区中主要清除两种垃圾：
                      废弃常量
                         只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。
                         比如，一个字符串 "bingo" 进入了常量池，但是当前系统没有任何一个 String 对象引用常量池中的 "bingo" 常量，也没有其它地方引用这个字面量，必要的话，"bingo"常量会被清理出常量池。
                      无用的类
                         判定一个类是否是“无用的类”，条件较为苛刻。
                          1.该类的所有对象都已经被清除
                          2.加载该类的 ClassLoader 已经被回收
                          3.该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
              堆内存调优：
                -Xms   设置初始分配大小，默认为物理内存的 1/64
                -Xmx   最大分配内存，默认为物理内存的 1/4
                -XX:+PrintGCdETAILS   输出详细gc日志

                在生产时   -Xms -Xmx要配置相等，以免内存有波动
                类别     young    yong区 gc的变化 yong区总大小       堆gc 变化大小  堆区大小               消耗时间
                GC       [PSYoungGen:  0K->0K(3584K)]                6893K->6893K(11776K), 0.0006941 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
    3.执行引擎
        interpreter 解释器   jitCompiler 即时编译器 Gc 垃圾回收
